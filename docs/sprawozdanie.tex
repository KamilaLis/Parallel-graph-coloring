% !TeX encoding = UTF-8
% !TeX spellcheck = pl_PL
\documentclass{article}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\usepackage[]{polski}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{geometry}
 
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}

\usepackage{multirow}
\usepackage{pdfpages}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{black},
	keywordstyle=\color{blue},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	%numbers=left,                    
	%numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}
\date{}

\author{Katarzyna Dziewulska, Kamila Lis}

\title{RÃ³wnolegÅ‚e przetwarzanie grafu}
	%\\{\large Sprawozdanie 1. projektu}}
\bibliographystyle{plunsrt}

\begin{document}
	\maketitle
	W ramach projektu zostanie zaimplementowany algorytm kolorowania grafu w~wersji zwykÅ‚ej i~rÃ³wnolegÅ‚ej. SugerujÄ…c siÄ™ artykuÅ‚em \cite{article} postanowiono wykorzystaÄ‡ algorytm LF (Largest-First). Wersja rÃ³wnolegÅ‚a zostanie zrealizowana w~architekturze CUDA przy wykorzystaniu karty graficznej Nvidia.\\
	
	\section{Algorytm kolorowania}
	Kolorowanie wierzchoÅ‚kÃ³w polega na  przydzielaniu kolorÃ³w wierzchoÅ‚kom tak, Å¼eby dwa sÄ…siednie wierzchoÅ‚ki otrzymaÅ‚y rÃ³Å¼ne kolory. Najmniejsza liczba kolorÃ³w $k$ nazywana jest liczbÄ… chromatycznÄ…. W~celu reprezentacji pokolorowania przyjÄ™Å‚o siÄ™ oznaczaÄ‡ kolory kolejnymi liczbami naturalnymi. Kolorowanie grafÃ³w najczÄ™Å›ciej wykorzystywane jest do poszukiwania rozwiÄ…zaÅ„, w~ktÃ³rych unika siÄ™ konfliktÃ³w. Strategie kolorowania grafu zaleÅ¼Ä… od stawianych wymagaÅ„. Celem optymalnego kolorowania jest minimalizacja liczby uÅ¼ytych kolorÃ³w, podczas gdy kolorowanie zbalansowane dÄ…Å¼y do zapewnienia podobnej liczby wierzchoÅ‚kÃ³w w~kaÅ¼dym kolorze.
	\subsection{Sekwencyjny Largest First}
	Algorytm LF (ang. \textit{Largest-First}) koloruje wierzchoÅ‚ki w~kolejnoÅ›ci zgodnej z~ich stopniami -- wierzchoÅ‚ki sÄ… przeglÄ…dane i~kolorowane zachÅ‚annie, wedÅ‚ug nierosnÄ…cych stopni wierzchoÅ‚kowych. Algorytm ma na celu minimalizowanie maksymalnej liczby wykorzystanych kolorÃ³w. 	
	PoniÅ¼ej zamieszczono pseudokod obrazujÄ…cy kroki algorytmu:
	\\
	\\
	\begin{algorithm}[H]
		\SetAlgoLined
		%		\KwResult{Write here the result }
		%		initialization\;
		\For{dla kaÅ¼dego wierzchoÅ‚ka $v \in V$}{
			Policz stopieÅ„ $d(v)$.
		}
		Posortuj zbiÃ³r V nierosnÄ…co wedÅ‚ug stopni $d$ wierzchoÅ‚kÃ³w.
		\\
		\For{dla kaÅ¼dego wierzchoÅ‚ka $v \in V$}{
		$S' = S$
		\\
		Aktualizuj $S'$ - wykreÅ›l kolory sÄ…siadÃ³w wierzchoÅ‚ka $v$.
		\\
		Pokoloruj $v$ na najmniejszy kolor z $S'$.
		}
		\caption{Sekwencyjny Largest-First}
	\end{algorithm}
\
\\
\\
		$V$ - zbiÃ³r wierzchoÅ‚kÃ³w grafu
		\\
		$n$ - liczba wszystkich wierzchoÅ‚kÃ³w grafu
		\\
		$v \in 1,2 ...n$ - pojedyÅ„czy wierzchoÅ‚ek
		\\
		$S$ - zbiÃ³r wszystkich kolorÃ³w, liczba kolorÃ³w rÃ³wna jest liczbie wierzchoÅ‚kÃ³w
		\\
		$d(v)$ - stopieÅ„ wierzchoÅ‚ka $v$

	\subsection{Metoda rÃ³wnolegÅ‚a}
	RÃ³wnolegÅ‚e metody kolorowania grafÃ³w sÄ… oparte na obserwacji, Å¼e kaÅ¼dy niezaleÅ¼ny zbiÃ³r wierzchoÅ‚kÃ³w, czyli taki w~ktÃ³rym nie ma Å¼adnych wierzchoÅ‚kÃ³w sÄ…siadujÄ…cych ze sobÄ…, moÅ¼e byÄ‡ kolorowany rÃ³wnolegle. RÃ³Å¼nice pomiÄ™dzy metodami sprowadzajÄ… siÄ™ do sposobu wyboru niezaleÅ¼nego zbioru i~samego kolorowania wierzchoÅ‚kÃ³w. NiezaleÅ¼ny zbiÃ³r wierzchoÅ‚kÃ³w jest konstruowany jako podgraf indukowany zawierajÄ…cy jedynie niepokolorowane wierzchoÅ‚ki. NajogÃ³lniej procedurÄ™ rÃ³wnolegÅ‚ego kolorowania moÅ¼na przedstawiÄ‡ nastÄ™pujÄ…co:
	\\
	
\begin{algorithm}[H]
	\SetAlgoLined
	%		\KwResult{Write here the result }
	%		initialization\;
	\While{$|G|>0$}{
		z grafu $G$ wybierz zbiÃ³r niezaleÅ¼nych wierzchoÅ‚kÃ³w $U$\;
		koloruj wszystkie wierzchoÅ‚ki z $U$\;
		$G:=G-U$\;
		%			\eIf{condition}{
		%				instructions1\;
		%				instructions2\;
		%			}{
		%			instructions3\;
		%		}
	}
	\caption{Kolorowanie rÃ³wnolegÅ‚e}
\end{algorithm}
%	\begin{lstlisting}
%	
%	while (|G|>0) do in parallel
%		choose an independent set U from G
%		color all vertices in U
%		G:=G-U
%	end do
%	\end{lstlisting}
\ \\ 

Algorytm LF w wersji zrÃ³wnoleglonej polega na "rÃ³wnolegÅ‚ym" szukaniu niezaleÅ¼nego zbioru wierzchoÅ‚kÃ³w (niekoniecznie jest on maksymalny), wybierajÄ…c te wierzchoÅ‚ki, ktÃ³re lokalnie sÄ… najwiÄ™kszego stopnia, a nastÄ™pnie kolorowaniu ich. Najpierw przydzielamy kaÅ¼demu wierzchoÅ‚kowi losowÄ… liczbÄ™ oraz obliczamy jego stopieÅ„. NastÄ™pie rÃ³wnolegle sprawdzany jest stopieÅ„ kaÅ¼dego wierzchoÅ‚ka (kaÅ¼dy wierzchoÅ‚ek rozpatrywany jest w oddzielnym wÄ…tku). JeÅ›li stopieÅ„ ten jest wiÄ™kszy od stopni sÄ…siadujÄ…cych wierzchoÅ‚kÃ³w, to wierzchoÅ‚ek ten jest wÅ‚Ä…czany do aktualnie tworzonego zbioru niezaleÅ¼nego. W przypadku konfliktu stopni decyduje wiÄ™ksza wartoÅ›Ä‡ przydzielonej na poczÄ…tku liczby losowej. Po utworzeniu zbioru niezaleÅ¼nego wierzchoÅ‚ki do niego naleÅ¼Ä…ce sÄ… rÃ³wnolegle kolorowane na  najmniejszy kolor, ktÃ³ry nie zostaÅ‚ uÅ¼yty do pokolorowania ich sÄ…siadÃ³w. W kolejnych iteracjach zbiory niezaleÅ¼ne wierzchoÅ‚kÃ³w sÄ… tworzone z wyÅ‚Ä…czeniem wierzchoÅ‚kÃ³w juÅ¼ pokolorowanych.  
\\ \\	
	$V$ - zbiÃ³r wierzchoÅ‚kÃ³w grafu
	\\
	$I$ - aktualny w danej iteracji niezaleÅ¼ny zbiÃ³r wierzchoÅ‚kÃ³w grafu
	\\
	$U$ - aktualny w danej iteracji zbiÃ³r pozostaÅ‚ych do pokolorowania wierzchoÅ‚kÃ³w grafu
	\\
	$d(v)$ - stopieÅ„ wierzchoÅ‚ka $v$
	\\
	$n$ - liczba wszystkich wierzchoÅ‚kÃ³w grafu
	\\
	$v \in 1,2 ...n$ - pojedyÅ„czy wierzchoÅ‚ek
	\\
	$S$ - zbiÃ³r wszystkich kolorÃ³w, liczba kolorÃ³w rÃ³wna jest liczbie wierzchoÅ‚kÃ³w
	\\
	$x$ - liczba losowa
	 \\ 
\begin{algorithm}[H]
	\SetAlgoLined
	%		\KwResult{Write here the result }
	%		initialization\;
	\For{dla kaÅ¼dego wierzchoÅ‚ka $v \in V$}{
		Policz stopieÅ„ $d(v)$.
		\\
		Przypisz losowÄ… liczbÄ™ $x$.
	}
	$U = V$
	\\
	\While{$|U|>0$}{
		\For{dla kaÅ¼dego wierzchoÅ‚ka $v \in U$ wykonuj rÃ³wnolegle}{
			I = \{$v$, takie Å¼e $d(v)>d(u)$ dla kaÅ¼dego sÄ…siada $u$ wierzchoÅ‚ka v, $u \in U$\}	
			\\
			\For{ dla kaÅ¼dego wierzchoÅ‚ka $v'\in I$ wykonuj rÃ³wnolegle}{
				$S' = S$
				\\
				Aktualizuj $S'$ - wykreÅ›l kolory sÄ…siadÃ³w wierzchoÅ‚ka $v'$.
				\\
				Pokoloruj $v'$ na najmniejszy kolor z $S'$.
			}
		}
		$U=U-I$
	}
	\caption{RÃ³wnolegÅ‚y Largest-First}
\end{algorithm}

%	\begin{lstlisting}
%	
%	while (|G|>0) do
%		for all vertices v in G do in parallel
%			U:={v such that deg(v)>deg(u) for all neighbors u in W\X}
%			for all vertices v' in U do in parallel
%				S:={colors of all neighbors of v'}
%				c(v'):=minimum color not in S
%			end do
%		end do
%		G:=G-U
%	end do
%	\end{lstlisting}
%For ecient implementation on distributed
%memory parallel computers, the information must also be local in the processor grid , so
%that the amount of communication is minimized. This means that the distribution of the
%graph over processors must be such that the number of edges crossing processor boundaries
%is minimized. This is the standard graph partitioning problem[]

  


 
	\section{Struktury danych}
	Pierwszym krokiem do rozwiÄ…zania problemu kolorowania grafu jest znalezienie odpowiedniej struktury danych najlepiej opisujÄ…cej strukturÄ™ grafu. W~artykule \cite{Shen2017} autorzy sugerujÄ… wykorzystanie macierzy sÄ…siedztwa jako odpowiedniej reprezentacji dla skomplikowanych algorytmÃ³w. Natomiast w~\cite{SINGH20155} zauwaÅ¼ono, Å¼e macierz sÄ…siedztwa marnuje duÅ¼o pamiÄ™ci w~przypadku ,,rzadkiego'' grafu, dlatego lista sÄ…siedztwa byÅ‚aby lepszym sposobem reprezentacji takiego grafu. W~GPU CUDA uzyskuje dostÄ™p do pamiÄ™ci w~tablicy, wiÄ™c z~powodu rÃ³Å¼nej wielkoÅ›ci listy krawÄ™dzi trudnej jest korzystaÄ‡ z~listy sÄ…siedztwa. MoÅ¼liwym rozwiÄ…zaniem jest wykorzystanie biblioteki nvGRAPH napisanej z~myÅ›lÄ… o~algorytmach grafowych. Struktura grafowa jest zaleÅ¼na od wybranej topologii. PrzykÅ‚adowo:
	\begin{lstlisting}
	
	struct nvgraphCSRTopology32I_st {
		int nvertices;
		int nedges;
		int *source_offsets;
		int *destination_indices;
	};
	typedef struct nvgraphCSRTopology32I_st *nvgraphCSRTopology32I_t;
	\end{lstlisting}
	gdzie
	\begin{itemize}
		\itemsep0em
		\item \texttt{nvertices} -- liczba wierzchoÅ‚kÃ³w grafu
		\item \texttt{nedges} -- liczba krawÄ™dzi grafu
		\item \texttt{source\_offsets} -- tablica o~rozmiarze $nvertices+1$ , gdzie $i$-ty element to numer indeksu pierwszej z~krawÄ™dzi wychodzÄ…cych z~tego wierzchoÅ‚ka w~tablicy krawÄ™dzi $destination\_indices$; ostatni element przechowuje liczbÄ™ wszystkich krawÄ™dzi
		\item \texttt{destination\_indices} -- tablica o~rozmiarze $nedges$, gdzie kaÅ¼da wartoÅ›Ä‡ to numer wierzchoÅ‚ka, do ktÃ³rego dochodzi $i$-ta krawÄ™dÅº
	\end{itemize}
	Listy wierzchoÅ‚kÃ³w i~krawÄ™dzi pozwalajÄ… nam na okreÅ›lenie, ktÃ³re wierzchoÅ‚ki sÄ…siadujÄ… ze sobÄ…. Dla implementacji algorytmu LF kaÅ¼dy z~wierzchoÅ‚kÃ³w powinien byÄ‡ dodatkowo opisany przez trzy parametry:
	\begin{itemize}
		\itemsep0em
		\item swÃ³j stopieÅ„ $deg(v)$,
		\item losowÄ… wartoÅ›Ä‡ $rndvalue(v)$, 
		\item listÄ™ zakazanych kolorÃ³w uÅ¼ytych juÅ¼ przez sÄ…siadÃ³w $usedcolor(v)$. 
	\end{itemize}
	Dla grafÃ³w nieskierowanych stopniem wierzchoÅ‚ka bÄ™dzie liczba wszystkich incydentnych krawÄ™dzi, a~tym samym rÃ³Å¼nica miÄ™dzy $i$ i~$i+1$ wartoÅ›ciÄ… w~tablicy wierzchoÅ‚kÃ³w. WartoÅ›Ä‡ losowa moÅ¼e zostaÄ‡ wylosowana i~przydzielona raz, na poczÄ…tku dziaÅ‚ania programu. Lista zakazanych kolorÃ³w moÅ¼e zostaÄ‡ zastÄ…piona caÅ‚kowitÄ… liczbÄ… naturalnÄ… oznaczajÄ…cÄ… nastÄ™pny kolor do wykorzystania (zakÅ‚adajÄ…c, Å¼e rozpoczynamy od ,,koloru'' 0, a~nastÄ™pne okreÅ›lamy przez inkrementacjÄ™). Parametry te moÅ¼na utoÅ¼samiÄ‡ z~wierzchoÅ‚kami przy wykorzystaniu funkcji \texttt{nvgraphAllocateVertexData} oraz \texttt{nvgraphSetVertexData}.
	
	\section{Projekty testÃ³w}
	PoprawnoÅ›Ä‡ obu implementacji algorytmu bÄ™dzie sprawdzana przez dodatkowo zaimplementowanÄ… funkcjÄ™, uruchamianÄ… dla wszystkich grafÃ³w, na ktÃ³rych wykonywane bÄ™dzie kolorowanie. ZarÃ³wno dla wyniku dziaÅ‚ania implementacji sekwencyjnej jak i~rÃ³wnolegÅ‚ej algorytmu, funkcja sprawdzi kaÅ¼dy wierzchoÅ‚ek grafu oraz jego sÄ…siadÃ³w. JeÅ¼eli znalezione zostanÄ… jakiekolwiek dwa sÄ…siadujÄ…ce ze sobÄ… wierzchoÅ‚ki, ktÃ³re zostaÅ‚y pokolorowane na ten sam kolor oznaczaÄ‡ to bÄ™dzie bÅ‚Ä™dnÄ… implementacjÄ™ oraz koniecznoÅ›Ä‡ jej poprawienia. DziaÅ‚anie algorytmu sekwencyjnego i~rÃ³wnolegÅ‚ego przetestowane zostanie na grafach dostÄ™pnych w~internecie miÄ™dzy innymi na stronie \url{http://mat.gsia.cmu.edu/COLOR/instances.html}. Testowanie przeprowadzone zostanie dla grafÃ³w o~liczbie wierzchoÅ‚kÃ³w rzÄ™du od kilkudziesiÄ…t do tysiÄ…ca, oraz liczbie krawÄ™dzi rzÄ™du od kilkudziesiÄ…t do kilkuset tysiÄ™cy (jeÅ›li moc obliczeniowa sprzÄ™tu podoÅ‚a takiej ich liczbie). Implementacje porÃ³wnywane bÄ™dÄ… ze wzglÄ™du na czas znalezienia rozwiÄ…zania oraz liczbÄ™ uÅ¼ytych w~rozwiÄ…zaniu kolorÃ³w. Dodatkowo implementacja rÃ³wnolegÅ‚a sprawdzona zostanie na dwÃ³ch kartach graficznych: GForce 920M oraz GForce GT 525M.
	%\section{ZaÅ‚oÅ¼enia programu}
	
	\bibliography{bibliografia}

 
%	\begin{table}[H]
%		\caption{WartoÅ›Ä‡ Å›rednia i~mediana dla kolejnych cech w~zbiorze uczÄ…cym}
%		\label{}
%		\begin{tabular}{r|c c c c c c c}
%			 & 2& 3 &4& 5& 6& 7& 8\\
%			 \hline
%			Å›rednia  & 1.8679e-01 &  1.4839e-02 &  2.1045e-01 &  2.0882e-01 &  7.9658e+01  & 1.0604e+00  & 9.0846e-03\\
%			%\hline
%			mediana &  1.8259e-01 &  1.4785e-04 &  1.7434e-04 &  1.9996e-06 & -8.9358e-11  & 1.3626e-10 & -1.8427e-14 \\
%		\end{tabular} 
%	\end{table}


%	\begin{figure}[h]
%		\centering
%		\includegraphics[width=1\textwidth]{images/wybor_cech.png}
%		\caption{Wykres wartoÅ›ci cech 2 i~4.}
%		\label{24}	
%	\end{figure}

\end{document}