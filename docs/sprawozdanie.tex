% !TeX encoding = UTF-8
% !TeX spellcheck = pl_PL
\documentclass{article}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\usepackage[]{polski}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{geometry}
 
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}

\usepackage{multirow}
\usepackage{pdfpages}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{black},
	keywordstyle=\color{blue},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	%numbers=left,                    
	%numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}
\date{}

\author{Katarzyna Dziewulska, Kamila Lis}

\title{RÃ³wnolegÅ‚e przetwarzanie grafu}
	%\\{\large Sprawozdanie 1. projektu}}
\bibliographystyle{plunsrt}

\begin{document}
	\maketitle
	W ramach projektu zostanie zaimplementowany algorytm kolorowania grafu w~wersji zwykÅ‚ej i~rÃ³wnolegÅ‚ej. SugerujÄ…c siÄ™ artykuÅ‚em \cite{article} postanowiono wykorzystaÄ‡ algorytm LF (Largest-First). Wersja rÃ³wnolegÅ‚a zostanie zrealizowana w~architekturze CUDA przy wykorzystaniu karty graficznej Nvidia.\\
	
	\section{Algorytm kolorowania}
	Kolorowanie wierzchoÅ‚kÃ³w polega na  przydzielaniu kolorÃ³w wierzchoÅ‚kom tak, Å¼eby dwa sÄ…siednie wierzchoÅ‚ki otrzymaÅ‚y rÃ³Å¼ne kolory. Najmniejsza liczba kolorÃ³w $k$ nazywana jest liczbÄ… chromatycznÄ…. W~celu reprezentacji pokolorowania przyjÄ™Å‚o siÄ™ oznaczaÄ‡ kolory kolejnymi liczbami naturalnymi. Kolorowanie grafÃ³w najczÄ™Å›ciej wykorzystywane jest do poszukiwania rozwiÄ…zaÅ„, w~ktÃ³rych unika siÄ™ konfliktÃ³w. Strategie kolorowania grafu zaleÅ¼Ä… od stawianych wymagaÅ„. Celem optymalnego kolorowania jest minimalizacja liczby uÅ¼ytych kolorÃ³w, podczas gdy kolorowanie zbalansowane dÄ…Å¼y do zapewnienia podobnej liczby wierzchoÅ‚kÃ³w w~kaÅ¼dym kolorze.
	\subsection{Sekwencyjny Largest First}
	Algorytm LF (ang. \textit{Largest-First}) koloruje wierzchoÅ‚ki w~kolejnoÅ›ci zgodnej z~ich stopniami -- wierzchoÅ‚ki sÄ… przeglÄ…dane i~kolorowane zachÅ‚annie, wedÅ‚ug nierosnÄ…cych stopni wierzchoÅ‚kowych. Algorytm ma na celu minimalizowanie maksymalnej liczby wykorzystanych kolorÃ³w. 	
	PoniÅ¼ej zamieszczono pseudokod obrazujÄ…cy kroki algorytmu:
	\\
	\\
	\begin{algorithm}[H]
		\SetAlgoLined
		%		\KwResult{Write here the result }
		%		initialization\;
		\For{dla kaÅ¼dego wierzchoÅ‚ka $v \in V$}{
			Policz stopieÅ„ $d(v)$.
		}
		Posortuj zbiÃ³r V nierosnÄ…co wedÅ‚ug stopni $d$ wierzchoÅ‚kÃ³w.
		\\
		\For{dla kaÅ¼dego wierzchoÅ‚ka $v \in V$}{
		$S' = S$
		\\
		Aktualizuj $S'$ - wykreÅ›l kolory sÄ…siadÃ³w wierzchoÅ‚ka $v$.
		\\
		Pokoloruj $v$ na najmniejszy kolor z $S'$.
		}
		\caption{Sekwencyjny Largest-First}
	\end{algorithm}
\
\\
\\
		$V$ - zbiÃ³r wierzchoÅ‚kÃ³w grafu
		\\
		$n$ - liczba wszystkich wierzchoÅ‚kÃ³w grafu
		\\
		$v \in 1,2 ...n$ - pojedyÅ„czy wierzchoÅ‚ek
		\\
		$S$ - zbiÃ³r wszystkich kolorÃ³w, liczba kolorÃ³w rÃ³wna jest liczbie wierzchoÅ‚kÃ³w
		\\
		$d(v)$ - stopieÅ„ wierzchoÅ‚ka $v$

	\subsection{Metoda rÃ³wnolegÅ‚a}
	RÃ³wnolegÅ‚e metody kolorowania grafÃ³w sÄ… oparte na obserwacji, Å¼e kaÅ¼dy niezaleÅ¼ny zbiÃ³r wierzchoÅ‚kÃ³w, czyli taki w~ktÃ³rym nie ma Å¼adnych wierzchoÅ‚kÃ³w sÄ…siadujÄ…cych ze sobÄ…, moÅ¼e byÄ‡ kolorowany rÃ³wnolegle. RÃ³Å¼nice pomiÄ™dzy metodami sprowadzajÄ… siÄ™ do sposobu wyboru niezaleÅ¼nego zbioru i~samego kolorowania wierzchoÅ‚kÃ³w. NiezaleÅ¼ny zbiÃ³r wierzchoÅ‚kÃ³w jest konstruowany jako podgraf indukowany zawierajÄ…cy jedynie niepokolorowane wierzchoÅ‚ki. NajogÃ³lniej procedurÄ™ rÃ³wnolegÅ‚ego kolorowania moÅ¼na przedstawiÄ‡ nastÄ™pujÄ…co:
	\\
	
\begin{algorithm}[H]
	\SetAlgoLined
	%		\KwResult{Write here the result }
	%		initialization\;
	\While{$|G|>0$}{
		z grafu $G$ wybierz zbiÃ³r niezaleÅ¼nych wierzchoÅ‚kÃ³w $U$\;
		koloruj wszystkie wierzchoÅ‚ki z $U$\;
		$G:=G-U$\;
		%			\eIf{condition}{
		%				instructions1\;
		%				instructions2\;
		%			}{
		%			instructions3\;
		%		}
	}
	\caption{Kolorowanie rÃ³wnolegÅ‚e}
\end{algorithm}
%	\begin{lstlisting}
%	
%	while (|G|>0) do in parallel
%		choose an independent set U from G
%		color all vertices in U
%		G:=G-U
%	end do
%	\end{lstlisting}
\ \\ 

Algorytm LF w wersji zrÃ³wnoleglonej polega na "rÃ³wnolegÅ‚ym" szukaniu niezaleÅ¼nego zbioru wierzchoÅ‚kÃ³w (niekoniecznie jest on maksymalny), wybierajÄ…c te wierzchoÅ‚ki, ktÃ³re lokalnie sÄ… najwiÄ™kszego stopnia, a nastÄ™pnie kolorowaniu ich. Najpierw przydzielamy kaÅ¼demu wierzchoÅ‚kowi losowÄ… liczbÄ™ oraz obliczamy jego stopieÅ„. NastÄ™pie rÃ³wnolegle sprawdzany jest stopieÅ„ kaÅ¼dego wierzchoÅ‚ka (kaÅ¼dy wierzchoÅ‚ek rozpatrywany jest w oddzielnym wÄ…tku). JeÅ›li stopieÅ„ ten jest wiÄ™kszy od stopni sÄ…siadujÄ…cych wierzchoÅ‚kÃ³w, to wierzchoÅ‚ek ten jest wÅ‚Ä…czany do aktualnie tworzonego zbioru niezaleÅ¼nego. W przypadku konfliktu stopni decyduje wiÄ™ksza wartoÅ›Ä‡ przydzielonej na poczÄ…tku liczby losowej. Po utworzeniu zbioru niezaleÅ¼nego wierzchoÅ‚ki do niego naleÅ¼Ä…ce sÄ… rÃ³wnolegle kolorowane na  najmniejszy kolor, ktÃ³ry nie zostaÅ‚ uÅ¼yty do pokolorowania ich sÄ…siadÃ³w. W kolejnych iteracjach zbiory niezaleÅ¼ne wierzchoÅ‚kÃ³w sÄ… tworzone z wyÅ‚Ä…czeniem wierzchoÅ‚kÃ³w juÅ¼ pokolorowanych.  
\\ \\	
	$V$ - zbiÃ³r wierzchoÅ‚kÃ³w grafu
	\\
	$I$ - aktualny w danej iteracji niezaleÅ¼ny zbiÃ³r wierzchoÅ‚kÃ³w grafu
	\\
	$U$ - aktualny w danej iteracji zbiÃ³r pozostaÅ‚ych do pokolorowania wierzchoÅ‚kÃ³w grafu
	\\
	$d(v)$ - stopieÅ„ wierzchoÅ‚ka $v$
	\\
	$n$ - liczba wszystkich wierzchoÅ‚kÃ³w grafu
	\\
	$v \in 1,2 ...n$ - pojedyÅ„czy wierzchoÅ‚ek
	\\
	$S$ - zbiÃ³r wszystkich kolorÃ³w, liczba kolorÃ³w rÃ³wna jest liczbie wierzchoÅ‚kÃ³w
	\\
	$x$ - liczba losowa
	 \\ 
\begin{algorithm}[H]
	\SetAlgoLined
	%		\KwResult{Write here the result }
	%		initialization\;
	\For{dla kaÅ¼dego wierzchoÅ‚ka $v \in V$}{
		Policz stopieÅ„ $d(v)$.
		\\
		Przypisz losowÄ… liczbÄ™ $x$.
	}
	$U = V$
	\\
	\While{$|U|>0$}{
		\For{dla kaÅ¼dego wierzchoÅ‚ka $v \in U$ wykonuj rÃ³wnolegle}{
			I = \{$v$, takie Å¼e $d(v)>d(u)$ dla kaÅ¼dego sÄ…siada $u$ wierzchoÅ‚ka v, $u \in U$\}	
			\\
			\For{ dla kaÅ¼dego wierzchoÅ‚ka $v'\in I$ wykonuj rÃ³wnolegle}{
				$S' = S$
				\\
				Aktualizuj $S'$ - wykreÅ›l kolory sÄ…siadÃ³w wierzchoÅ‚ka $v'$.
				\\
				Pokoloruj $v'$ na najmniejszy kolor z $S'$.
			}
		}
		$U=U-I$
	}
	\caption{RÃ³wnolegÅ‚y Largest-First}
\end{algorithm}

%	\begin{lstlisting}
%	
%	while (|G|>0) do
%		for all vertices v in G do in parallel
%			U:={v such that deg(v)>deg(u) for all neighbors u in W\X}
%			for all vertices v' in U do in parallel
%				S:={colors of all neighbors of v'}
%				c(v'):=minimum color not in S
%			end do
%		end do
%		G:=G-U
%	end do
%	\end{lstlisting}
%For ecient implementation on distributed
%memory parallel computers, the information must also be local in the processor grid , so
%that the amount of communication is minimized. This means that the distribution of the
%graph over processors must be such that the number of edges crossing processor boundaries
%is minimized. This is the standard graph partitioning problem[]

  


 
	\section{Struktury danych}
	Pierwszym krokiem do rozwiÄ…zania problemu kolorowania grafu jest znalezienie odpowiedniej struktury danych najlepiej opisujÄ…cej strukturÄ™ grafu. W~artykule \cite{Shen2017} autorzy sugerujÄ… wykorzystanie macierzy sÄ…siedztwa jako odpowiedniej reprezentacji dla skomplikowanych algorytmÃ³w. Natomiast w~\cite{SINGH20155} zauwaÅ¼ono, Å¼e macierz sÄ…siedztwa marnuje duÅ¼o pamiÄ™ci w~przypadku ,,rzadkiego'' grafu, dlatego lista sÄ…siedztwa byÅ‚aby lepszym sposobem reprezentacji takiego grafu. W~GPU CUDA uzyskuje dostÄ™p do pamiÄ™ci w~tablicy, wiÄ™c z~powodu rÃ³Å¼nej wielkoÅ›ci listy krawÄ™dzi trudnej jest korzystaÄ‡ z~listy sÄ…siedztwa. MoÅ¼liwym rozwiÄ…zaniem jest wykorzystanie biblioteki nvGRAPH \cite{nvgraph} napisanej z~myÅ›lÄ… o~algorytmach grafowych. Struktura grafowa jest zaleÅ¼na od wybranej topologii. PrzykÅ‚adowo, dla formatu CSR (\textit{compressed sparse row}):
	\begin{lstlisting}[caption={Struktura formatu CSR z biblioteki nvGRAPH.}]
	
	struct nvgraphCSRTopology32I_st {
		int nvertices;
		int nedges;
		int *source_offsets;
		int *destination_indices;
	};
	typedef struct nvgraphCSRTopology32I_st *nvgraphCSRTopology32I_t;
	\end{lstlisting}
	gdzie
	\begin{itemize}
		\itemsep0em
		\item \texttt{nvertices} -- liczba wierzchoÅ‚kÃ³w grafu
		\item \texttt{nedges} -- liczba krawÄ™dzi grafu
		\item \texttt{source\_offsets} -- tablica o~rozmiarze $nvertices+1$ , gdzie $i$-ty element to numer indeksu pierwszej z~krawÄ™dzi wychodzÄ…cych z~$i$-tego wierzchoÅ‚ka w~tablicy krawÄ™dzi $destination\_indices$; ostatni element przechowuje liczbÄ™ wszystkich krawÄ™dzi
		\item \texttt{destination\_indices} -- tablica o~rozmiarze $nedges$, gdzie kaÅ¼da wartoÅ›Ä‡ to numer wierzchoÅ‚ka, do ktÃ³rego dochodzi $i$-ta krawÄ™dÅº
	\end{itemize}
	Listy wierzchoÅ‚kÃ³w i~krawÄ™dzi pozwalajÄ… nam na okreÅ›lenie, ktÃ³re wierzchoÅ‚ki sÄ…siadujÄ… ze sobÄ…. Dla implementacji algorytmu LF kaÅ¼dy z~wierzchoÅ‚kÃ³w powinien byÄ‡ dodatkowo opisany przez trzy parametry:
	\begin{itemize}
		\itemsep0em
		\item swÃ³j stopieÅ„ $deg(v)$,
		\item losowÄ… wartoÅ›Ä‡, 
		\item kolor. 
	\end{itemize}
	Dla grafÃ³w nieskierowanych stopniem wierzchoÅ‚ka bÄ™dzie liczba wszystkich incydentnych krawÄ™dzi, a~tym samym rÃ³Å¼nica miÄ™dzy $i$ i~$i+1$ wartoÅ›ciÄ… w~tablicy \texttt{source\_offsets}. WartoÅ›Ä‡ losowa moÅ¼e zostaÄ‡ wylosowana i~przydzielona raz, na poczÄ…tku dziaÅ‚ania programu. Kolor moÅ¼e zostaÄ‡ opisany caÅ‚kowitÄ… liczbÄ… naturalnÄ… (zakÅ‚adajÄ…c, Å¼e $-1$ oznacza brak przydzielonego koloru, rozpoczynamy od ,,koloru'' 0, a~nastÄ™pne okreÅ›lamy przez inkrementacjÄ™). Parametry te moÅ¼na utoÅ¼samiÄ‡ z~wierzchoÅ‚kami przy wykorzystaniu funkcji \texttt{nvgraphAllocateVertexData} oraz \texttt{nvgraphSetVertexData}.
	
	\section{Projekty testÃ³w}
	PoprawnoÅ›Ä‡ obu implementacji algorytmu bÄ™dzie sprawdzana przez dodatkowo zaimplementowanÄ… funkcjÄ™, uruchamianÄ… dla wszystkich grafÃ³w, na ktÃ³rych wykonywane bÄ™dzie kolorowanie. ZarÃ³wno dla wyniku dziaÅ‚ania implementacji sekwencyjnej jak i~rÃ³wnolegÅ‚ej algorytmu, funkcja sprawdzi kaÅ¼dy wierzchoÅ‚ek grafu oraz jego sÄ…siadÃ³w. JeÅ¼eli znalezione zostanÄ… jakiekolwiek dwa sÄ…siadujÄ…ce ze sobÄ… wierzchoÅ‚ki, ktÃ³re zostaÅ‚y pokolorowane na ten sam kolor oznaczaÄ‡ to bÄ™dzie bÅ‚Ä™dnÄ… implementacjÄ™ oraz koniecznoÅ›Ä‡ jej poprawienia. DziaÅ‚anie algorytmu sekwencyjnego i~rÃ³wnolegÅ‚ego przetestowane zostanie na grafach dostÄ™pnych w~internecie miÄ™dzy innymi na stronie \url{http://mat.gsia.cmu.edu/COLOR/instances.html}. Testowanie przeprowadzone zostanie dla grafÃ³w o~liczbie wierzchoÅ‚kÃ³w rzÄ™du od kilkudziesiÄ…t do tysiÄ…ca, oraz liczbie krawÄ™dzi rzÄ™du od kilkudziesiÄ…t do kilkuset tysiÄ™cy (jeÅ›li moc obliczeniowa sprzÄ™tu podoÅ‚a takiej ich liczbie). Implementacje porÃ³wnywane bÄ™dÄ… ze wzglÄ™du na czas znalezienia rozwiÄ…zania oraz liczbÄ™ uÅ¼ytych w~rozwiÄ…zaniu kolorÃ³w. Dodatkowo implementacja rÃ³wnolegÅ‚a sprawdzona zostanie na dwÃ³ch kartach graficznych: GForce 920M oraz GForce GT 525M.
	%\section{ZaÅ‚oÅ¼enia programu}
	
	\section{Etap 3}
	\subsection{Struktury danych - aktualizacja}
	Podczas implementacji algorytmu zdecydowano siÄ™ zrezygnowaÄ‡ z biblioteki nvGRAPH do przechowywania grafu, poniewaÅ¼ funkcje tej biblioteki okazaÅ‚y siÄ™ nieprzydatne w implementacji. Zachowano jednak format CSR przechowywania grafu, dla ktÃ³rego powstaÅ‚a struktura analogiczna do tej z biblioteki nvGRAPH zamieszczonej na listingu 1. Struktura formatu CSR jest to skrÃ³cony zapis macierzy sÄ…siedztwa. Zawiera ona dwie zmienne przechowujÄ…ce liczbÄ™ wierzchoÅ‚kÃ³w i liczbÄ™ krawÄ™dzi, oraz dwie tablice jednowymiarowe. Tablica \textit{destination\_indices} przechowuje zapisane w ciÄ…gu numery sÄ…siadÃ³w kaÅ¼dego z wierzchoÅ‚kÃ³w, rozpoczynajÄ…c od najmniejszego wierzchoÅ‚ka. Z kolei tablica \textit{source\_offsets} zawiera indeksy tablicy \textit{destination\_indices} od ktÃ³rych rozpoczynajÄ… siÄ™ sÄ…siedzi kolejnych wierzchoÅ‚kÃ³w. Indeksy tablicy \textit{source\_offsets} to numery wierzchoÅ‚kÃ³w. Tak wiÄ™c dla wierzchoÅ‚ka np. nr $0$ wartoÅ›Ä‡ $source\_offsets[0]$ bÄ™dzie indeksem dla tablicy $destination\_indices$, od ktÃ³rego zaczynajÄ… siÄ™ numery jego sÄ…siadÃ³w.
	
	\subsection{Wyniki testÃ³w}
	Obie implementacje algorytmu byÅ‚y testowane na grafach o rÃ³Å¼nej liczbie wierzchoÅ‚kÃ³w i krawÄ™dzi. Dla kaÅ¼dego grafu zostaÅ‚o wykonane dziesiÄ™Ä‡ prÃ³b kolorowania algorytmem w wersji sekwencyjnej i dziesiÄ™Ä‡ prÃ³b algorytmem w wersji rÃ³wnolegÅ‚ej. NastÄ™pnie zostaÅ‚a policzona Å›rednia czasÃ³w wykonywania algorytmÃ³w oraz liczby przydzielonych kolorÃ³w. Testy algorytmÃ³w zostaÅ‚y wykonane na CPU (parametry). W wersji rÃ³wnolegÅ‚ej wykorzystano dodatkowo kartÄ™ graficznÄ… GForce 920M, zdolnoÅ›Ä‡ obliczeniowa 3.5, 2 multi-procesory. Docelowo testy miaÅ‚y byÄ‡ przeprowadzone takÅ¼e dla karty graficznej GForce GT 525M, jednak nie udaÅ‚o siÄ™ uruchomiÄ‡ na niej potrzebnych narzÄ™dzi. Oba algorytmy porÃ³wnywane byÅ‚y pod wzglÄ™dem liczby wykorzystanych kolorÃ³w oraz czasu wykonywania. Wyniki testÃ³w zamieszczone zostaÅ‚y w tabeli poniÅ¼ej. NiektÃ³re znalezione do testÃ³w grafy zawieraÅ‚y informacje o optymalnym kolorowaniu, ktÃ³re rÃ³wnieÅ¼ zamieszczono w tabeli. PoprawnoÅ›Ä‡ kolorowania sprawdzona zostaÅ‚a specjalnie napisanÄ… funkcjÄ… \verb|CheckIfCorrect|. Wyniki funkcji zostaÅ‚y przedstawione w kolumnie \textit{czy poprawnie?} w tabeli poniÅ¼ej.
	
	\begin{center}
	\hspace*{-1.5cm}	
	\begin{tabular}{|p{2cm}|p{1.7cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|} \hline
		\textbf{wierzchoÅ‚ki} & \textbf{krawÄ™dzie} & \multicolumn{3}{|c|}{\textbf{LF - sekwencyjny}} & \multicolumn{3}{|c|}{\textbf{LF - rÃ³wnolegÅ‚y}} & optymalne kolorowanie \\
		\hline
		 & & czy poprawnie? & liczba kolorÃ³w & czas kolorowania & czy poprawnie? & liczba kolorÃ³w & czas kolorowania & \\
		 \hline
		 $25$ & $320$ & tak & $7$ & $0.136$ ms & tak & $17$ & $1.410$ ms & $5$ \\
		 \hline
		$96$ & $1368$ & tak & $16$ & $0.366$ ms & tak & $46$ & $7.400$ ms & $12$ \\
		 \hline
		 $100$ & $2940$ & tak & $17$ & $0.373$ ms & tak & $60$ & $10.238$ ms & ? \\
		 \hline
		 $138$ & $986$ & tak & $11$ & $0.482$ ms & tak & $19$ & $2.368$ ms & $11$ \\
		\hline
		$144$ & $5192$ & tak & $20$ & $0.617$ ms & tak & $84$ & $23.456$ ms & ? \\
		\hline	
		$169$ & $6656$ & tak & $20$ & $0.870$ ms & tak & $97$ & $36.139$ ms & $13$ \\	 
		\hline		
		$256$ & $12640$ & tak & $26$ & $0.784$ ms & tak & $144$ & $57.164$ ms & ? \\
		\hline
	\end{tabular}
	\end{center}
		
	\subsection{Wnioski}
	
	Wszystkie testowane grafy zostaÅ‚y poprawnie pokolorowane dla obu wersji algorytmu. ZauwaÅ¼yÄ‡ moÅ¼na, Å¼e algorytm w wersji sekwencyjnej wykorzystuje mniej kolorÃ³w niÅ¼ algorytm w wersji rÃ³wnolegÅ‚ej, jednak nie zawsze znalezione rozwiÄ…zanie jest optymalne. Wynik taki byÅ‚ spodziewany, poniewaÅ¼ algorytm sekwencyjny wybierajÄ…c kolor dla wierzchoÅ‚ka bierze pod uwagÄ™ caÅ‚y graf, natomiast algorytm rÃ³wnolegÅ‚y wykonuje to samo jednak w kaÅ¼dej iteracji przetwarzajÄ…c jedynie niezaleÅ¼ny zbiÃ³r wierzchoÅ‚kÃ³w grafu, przez co wykorzystywane jest wiÄ™cej kolorÃ³w. Jako Å¼e algorytm w wersji rÃ³wnolegÅ‚ej koloruje jednoczeÅ›nie kilka wierzchoÅ‚kÃ³w, spodziewaÄ‡ by siÄ™ mogÅ‚o, Å¼e bÄ™dzie on dziaÅ‚aÅ‚ szybciej niÅ¼ ten w wersji sekwencyjnej. Dla testowanych grafÃ³w jednak algorytm rÃ³wnolegÅ‚y znalazÅ‚ wynik w dÅ‚uÅ¼szym czasie niÅ¼ sekwencyjny. Z powodu braku danych oraz ograniczonych moÅ¼liwoÅ›ci sprzÄ™towych nie przetestowano dziaÅ‚ania algorytmÃ³w na wiÄ™kszych grafach (o liczbie wierzchoÅ‚kÃ³w rzÄ™du np. kilkuset tysiÄ™cy), jednak przypuszcza siÄ™, Å¼e dla bardzo duÅ¼ych grafÃ³w czas kolorowania algorytmu rÃ³wnolegÅ‚ego bÄ™dzie mniejszy, poniewaÅ¼ wykorzystana bÄ™dzie tak duÅ¼a liczba wÄ…tkÃ³w (kaÅ¼dy wierzchoÅ‚ek w oddzielnym wÄ…tku), Å¼e spowoduje to sumarycznie szybsze wykonanie algorytmu kolorowania. Z powyÅ¼szej tabeli wynika, Å¼e algorytm rÃ³wnolegÅ‚y dziaÅ‚a znacznie szybciej dla grafÃ³w rzadkich (o niewielkiej liczbie krawÄ™dzi). Wniosek z powyÅ¼szych rozwaÅ¼aÅ„ jest taki, Å¼e jeÅ¼eli zaleÅ¼y nam na jak najmniejszej liczbie kolorÃ³w wykorzystywanych do kolorowania to naleÅ¼y wybraÄ‡ wersjÄ™ sekwencyjnÄ…. JeÅ›li chodzi o jak najszybsze pokolorowanie wtedy w zaleÅ¼noÅ›ci od liczby wierzchoÅ‚kÃ³w i krawÄ™dzi wybieramy tÄ… wersje algorytmu, ktÃ³ra dziaÅ‚a lepiej.
	
	\subsection{Perspektywy przyÅ›pieszenia algorytmu rÃ³wnolegÅ‚ego}
	JednÄ… z moÅ¼liwoÅ›ci przyÅ›pieszenia dziaÅ‚ania algorytmu rÃ³wnolegÅ‚ego jest zastÄ…pienie rÃ³wnoczesnego uruchamiania funkcji kolorujÄ…cej w oddzielnym wÄ…tku, dla kaÅ¼dego wierzchoÅ‚ka na kilkukrotne wykonanie funkcji dla wielu wierzchoÅ‚kÃ³w z wykorzystaniem tych samych wÄ…tkÃ³w. Taka zmiana powinna pozwoliÄ‡ na zmniejszenie czasu dziaÅ‚ania, poniewaÅ¼ koszt uruchomienia nowego wÄ…tku jest stosunkowo duÅ¼y. W ramach projektu nie wykonano testÃ³w dla tego podejÅ›cia dla zachowania czytelnoÅ›ci kodu.
	
	\bibliography{bibliografia}

 
%	\begin{table}[H]
%		\caption{WartoÅ›Ä‡ Å›rednia i~mediana dla kolejnych cech w~zbiorze uczÄ…cym}
%		\label{}
%		\begin{tabular}{r|c c c c c c c}
%			 & 2& 3 &4& 5& 6& 7& 8\\
%			 \hline
%			Å›rednia  & 1.8679e-01 &  1.4839e-02 &  2.1045e-01 &  2.0882e-01 &  7.9658e+01  & 1.0604e+00  & 9.0846e-03\\
%			%\hline
%			mediana &  1.8259e-01 &  1.4785e-04 &  1.7434e-04 &  1.9996e-06 & -8.9358e-11  & 1.3626e-10 & -1.8427e-14 \\
%		\end{tabular} 
%	\end{table}


%	\begin{figure}[h]
%		\centering
%		\includegraphics[width=1\textwidth]{images/wybor_cech.png}
%		\caption{Wykres wartoÅ›ci cech 2 i~4.}
%		\label{24}	
%	\end{figure}

\end{document}