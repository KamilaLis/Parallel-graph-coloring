% !TeX encoding = UTF-8
% !TeX spellcheck = pl_PL
\documentclass{article}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\usepackage[]{polski}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{geometry}
 
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}

\usepackage{multirow}
\usepackage{pdfpages}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{black},
	keywordstyle=\color{blue},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	%numbers=left,                    
	%numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}
\date{}

\author{Katarzyna Dziewulska, Kamila Lis}

\title{RÃ³wnolegÅ‚e przetwarzanie grafu}
	%\\{\large Sprawozdanie 1. projektu}}
\bibliographystyle{plunsrt}

\begin{document}
	\maketitle
	W ramach projektu zostanie zaimplementowany algorytm kolorowania grafu w wersji zwykÅ‚ej i rÃ³wnolegÅ‚ej. SugerujÄ…c siÄ™ artykuÅ‚em \cite{article} postanowiono wykorzystaÄ‡ algorytm LDF (Largest-Degree-First). Wersja rÃ³wnolegÅ‚a zostanie zrealizowana w architekturze CUDA przy wykorzystaniu karty graficznej Nvidia.\\
	
	\section{Algorytm kolorowania}
	Kolorowanie wierzchoÅ‚kÃ³w polega na  przydzielaniu kolorÃ³w wierzchoÅ‚kom tak, Å¼e by dwa sÄ…siednie wierzchoÅ‚ki otrzymaÅ‚y rÃ³Å¼ne kolory. Najmniejsza liczba kolorÃ³w $k$ nazywana jest liczbÄ… chromatycznÄ… i oznaczana jako $X(G)$. W celu reprezentacji pokolorowania przyjÄ™Å‚o siÄ™ oznaczaÄ‡ kolory kolejnymi liczbami naturalnymi. Kolorowanie grafÃ³w najczÄ™Å›ciej wykorzystywane jest do poszukiwania rozwiÄ…zaÅ„, w ktÃ³rych unika siÄ™ konfliktÃ³w. Strategie kolorowania grafu zaleÅ¼Ä… od stawianych wymagaÅ„. Celem optymalnego kolorowania jest minimalizacja liczby uÅ¼ytych kolorÃ³w, podczas gdy kolorowanie zbalansowane dÄ…Å¼y do zapewnienia podobnej liczby wierzchoÅ‚kÃ³w w kaÅ¼dym kolorze.
	\subsection{Sekwencyjny Largest Degree First}
	Algorytm LF (ang. \textit{Largest-Degree-First}) koloruje wierzchoÅ‚ki w kolejnoÅ›ci zgodnej z ich stopniami -- wierzchoÅ‚ki sÄ… przeglÄ…dane i kolorowane wedÅ‚ug nierosnÄ…cych stopni wierzchoÅ‚kowych (wierzchoÅ‚ek o najwiÄ™kszym stopniu jest kolorowany pierwszy). Algorytm ma celu minimalizowanie maksymalnej liczby wykorzystanych kolorÃ³w. 
	
	Jego podstawowa, sekwencyjna wersja, zakÅ‚ada nastÄ™pujÄ…ce kroki:
	\begin{enumerate}
		\itemsep0em
		\item przydziel wartoÅ›Ä‡ losowÄ… oraz okreÅ›l stopieÅ„ kaÅ¼dego wierzchoÅ‚ka,
		\item dla kaÅ¼dego wierzchoÅ‚ka sprawdÅº stopnie jego sÄ…siadÃ³w, jeÅ›li aktualny posiada najwiÄ™kszy przydziel kolor,
		\item konflikty stopni rozwiÄ…zywane sÄ… przez wybÃ³r wierzchoÅ‚ka o najwiÄ™kszej liczbie losowej
	\end{enumerate}
	
	\subsection{Metoda rÃ³wnolegÅ‚a}
	RÃ³wnolegÅ‚e metody kolorowania grafÃ³w sÄ… oparte na obserwacji, Å¼e kaÅ¼dy niezaleÅ¼ny zbiÃ³r wierzchoÅ‚kÃ³w, czyli taki w ktÃ³rym nie ma Å¼adnych wierzchoÅ‚kÃ³w sÄ…siadujÄ…cych ze sobÄ…, moÅ¼e byÄ‡ kolorowany rÃ³wnolegle. RÃ³Å¼nice pomiÄ™dzy metodami sprowadzajÄ… siÄ™ do sposobu wyboru niezaleÅ¼nego zbioru i samego kolorowania wierzchoÅ‚kÃ³w. NiezaleÅ¼ny zbiÃ³r wierzchoÅ‚kÃ³w jest konstruowany jako podgraf indukowany zawierajÄ…cy jedynie niepokolorowane wierzchoÅ‚ki. NajogÃ³lniej procedurÄ™ tÄ™ moÅ¼na przedstawiÄ‡ nastÄ™pujÄ…co:
	\begin{lstlisting}
	
	while (|G|>0) do in parallel
		choose an independent set U from G
		color all vertices in U
		G:=G-U
	end do
	\end{lstlisting}
	
	Do dalszego opisu przyjmijmy nomenklaturÄ™ zaproponowanÄ… w \cite{gis}:\\
	$U$ -- zbiÃ³r niezaleÅ¼nych wierzchoÅ‚kÃ³w,\\
	$W$ -- zbiÃ³r niepokolorowanych wierzchoÅ‚kÃ³w,\\
	$X$ -- podzbiÃ³r $W$ wierzchoÅ‚kÃ³w niebÄ™dÄ…cych sÄ…siadami Å¼adnego wierzchoÅ‚ka z $U$.
	
	Algorytm LF moÅ¼e zostaÄ‡ zrÃ³wnoleglony poprzez rÃ³wnolegÅ‚e znajdowanie zbioru niezaleÅ¼nych wierzchoÅ‚kÃ³w. poprzez wybieranie wierzchoÅ‚kÃ³w, ktÃ³rych stopnie sÄ… lokalnymi maksymami.
	ReguÅ‚a konstrukcji zbiorÃ³w niezaleÅ¼nych w przypadku RLF (ang. \textit{Recursive Largest First}) jest nastÄ™pujÄ…ca: jako pierwszy wierzchoÅ‚ek kaÅ¼dego nowo tworzonego zbioru niezaleÅ¼nego jest wybierany wierzchoÅ‚ek o najwiÄ™kszym stopniu w podgrafie $G[W]$. NastÄ™pnymi wierzchoÅ‚kami doÅ‚Ä…czanymi do zbioru niezaleÅ¼nego sÄ… te, ktÃ³re majÄ… najwiÄ™cej sÄ…siadÃ³w w zbiorze $W\verb|\|X$.
	\begin{lstlisting}
	
	while (|G|>0) do
		for all vertices v in G do in parallel
			U:={v such that deg(v)>deg(u) for all neighbors u in W\X}
			for all vertices v' in U do in parallel
				S:={colors of all neighbors of v'}
				c(v'):=minimum color not in S
			end do
		end do
		G:=G-U
	end do
	\end{lstlisting}
%For ecient implementation on distributed
%memory parallel computers, the information must also be local in the processor grid , so
%that the amount of communication is minimized. This means that the distribution of the
%graph over processors must be such that the number of edges crossing processor boundaries
%is minimized. This is the standard graph partitioning problem[]

  


 
	\section{Struktury danych}
	Pierwszym krokiem do rozwiÄ…zania problemu kolorowania grafu jest znalezienie odpowiedniej struktury danych najlepiej opisujÄ…cej strukturÄ™ grafu. W artykule \cite{Shen2017} autorzy sugerujÄ… wykorzystanie macierzy sÄ…siedztwa jako odpowiedniej reprezentacji dla skomplikowanych algorytmÃ³w. Natomiast w \cite{SINGH20155} zauwaÅ¼ono, Å¼e macierz sÄ…siedztwa marnuje duÅ¼o pamiÄ™ci w przypadku ,,rzadkiego'' wykresu, dlatego lista sÄ…siedztwa byÅ‚aby lepszym sposobem reprezentacji takiego wykresu. W GPU CUDA uzyskuje dostÄ™p do pamiÄ™ci w tablicy, wiÄ™c z powodu rÃ³Å¼nej wielkoÅ›ci listy krawÄ™dzi trudnej jest korzystaÄ‡ z listy sÄ…siedztwa. MoÅ¼liwym rozwiÄ…zaniem jest wykorzystanie biblioteki nvGRAPH napisanej z myÅ›lÄ… o algorytmach grafowych. Struktura grafowa jest zaleÅ¼na od wybranej topologii. PrzykÅ‚adowo:
	\begin{lstlisting}
	
	struct nvgraphCSRTopology32I_st {
		int nvertices;
		int nedges;
		int *source_offsets;
		int *destination_indices;
	};
	typedef struct nvgraphCSRTopology32I_st *nvgraphCSRTopology32I_t;
	\end{lstlisting}
	gdzie
	\begin{itemize}
		\itemsep0em
		\item \texttt{nvertices} -- liczba wierzchoÅ‚kÃ³w grafu
		\item \texttt{nedges} -- liczba krawÄ™dzi grafu
		\item \texttt{source\_offsets} -- tablica o rozmiarze $nvertices+1$ , gdzie $i$-ty element to numer indeksu pierwszej z krawÄ™dzi wychodzÄ…cych z tego wierzchoÅ‚ka w tablicy krawÄ™dzi $destination\_indices$; ostatni element przechowuje liczbÄ™ wszystkich krawÄ™dzi
		\item \texttt{destination\_indices} -- tablica o rozmiarze $nedges$, gdzie kaÅ¼da wartoÅ›Ä‡ to numer wierzchoÅ‚ka, do ktÃ³rego dochodzi $i$-ta krawÄ™dÅº
	\end{itemize}
	Listy wierzchoÅ‚kÃ³w i krawÄ™dzi pozwalajÄ… nam na okreÅ›lenie, ktÃ³re wierzchoÅ‚ki sÄ…siadujÄ… ze sobÄ…. Dla implementacji algorytmu LF kaÅ¼dy z wierzchoÅ‚kÃ³w powinien byÄ‡ dodatkowo opisany przez trzy parametry:
	\begin{itemize}
		\itemsep0em
		\item swÃ³j stopieÅ„ $deg(v)$,
		\item losowÄ… wartoÅ›Ä‡ $rndvalue(v)$, 
		\item listÄ™ zakazanych kolorÃ³w uÅ¼ytych juÅ¼ przez sÄ…siadÃ³w $usedcolor(v)$. 
	\end{itemize}
	Dla grafÃ³w nieskierowanych stopniem wierzchoÅ‚ka bÄ™dzie liczba wszystkich incydentnych krawÄ™dzi, a tym samym rÃ³Å¼nica miÄ™dzy $i$ i $i+1$ wartoÅ›ciÄ… w tablicy wierzchoÅ‚kÃ³w. WartoÅ›Ä‡ losowa moÅ¼e zostaÄ‡ wylosowana i przydzielona raz, na poczÄ…tku dziaÅ‚ania programu. Lista zakazanych kolorÃ³w moÅ¼e zostaÄ‡ zastÄ…piona caÅ‚kowitÄ… liczbÄ… naturalnÄ… oznaczajÄ…cÄ… nastÄ™pny kolor do wykorzystania (zakÅ‚adajÄ…c, Å¼e rozpoczynamy od ,,koloru'' 0, a nastÄ™pne okreÅ›lamy przez inkrementacjÄ™). Parametry te moÅ¼na utoÅ¼samiÄ‡ z wierzchoÅ‚kami przy wykorzystaniu funkcji \texttt{nvgraphAllocateVertexData} oraz \texttt{nvgraphSetVertexData}.
	
	\section{Projekty testÃ³w}
	PoprawnoÅ›Ä‡ obu implementacji algorytmu bÄ™dzie sprawdzana przez dodatkowo zaimplementowanÄ… funkcjÄ™, dla wszystkich grafÃ³w, na ktÃ³rych wykonywane bÄ™dzie kolorowanie. ZarÃ³wno dla wyniku dziaÅ‚ania implementacji sekwencyjnej jak i rÃ³wnolegÅ‚ej algorytmu, funkcja sprawdzi kaÅ¼dy wierzchoÅ‚ek grafu oraz jego sÄ…siadÃ³w. JeÅ¼eli znalezione zostanÄ… jakiekolwiek dwa sÄ…siadujÄ…ce ze sobÄ… wierzchoÅ‚ki, ktÃ³re zostaÅ‚y pokolorowane na ten sam kolor oznaczaÄ‡ to bÄ™dzie bÅ‚Ä™dnÄ… implementacjÄ™ oraz koniecznoÅ›Ä‡ jej poprawienia. DziaÅ‚anie algorytmu sekwencyjnego i rÃ³wnolegÅ‚ego przetestowane zostanie na grafach dostÄ™pnych w internecie miÄ™dzy innymi na stronie \textit{http://mat.gsia.cmu.edu/COLOR/instances.html}. Testowanie przeprowadzone zostanie dla grafÃ³w o liczbie wierzchoÅ‚kÃ³w rzÄ™du od kilkudziesiÄ…t do tysiÄ…ca, oraz liczbie krawÄ™dzi rzÄ™du od kilkudziesiÄ…t do kilkuset tysiÄ™cy (jeÅ›li moc obliczeniowa sprzÄ™tu podoÅ‚a takiej ich liczbie). Implementacje porÃ³wnywane bÄ™dÄ… ze wzglÄ™du na czas znalezienia rozwiÄ…zania oraz liczbÄ™ uÅ¼ytych w rozwiÄ…zaniu kolorÃ³w. Dodatkowo implementacja rÃ³wnolegÅ‚a sprawdzona zostanie na dwÃ³ch kartach graficznych: GForce 920M oraz GForce GT 525M.
	\section{ZaÅ‚oÅ¼enia programu}
	
	\bibliography{bibliografia}

 
%	\begin{table}[H]
%		\caption{WartoÅ›Ä‡ Å›rednia i mediana dla kolejnych cech w zbiorze uczÄ…cym}
%		\label{}
%		\begin{tabular}{r|c c c c c c c}
%			 & 2& 3 &4& 5& 6& 7& 8\\
%			 \hline
%			Å›rednia  & 1.8679e-01 &  1.4839e-02 &  2.1045e-01 &  2.0882e-01 &  7.9658e+01  & 1.0604e+00  & 9.0846e-03\\
%			%\hline
%			mediana &  1.8259e-01 &  1.4785e-04 &  1.7434e-04 &  1.9996e-06 & -8.9358e-11  & 1.3626e-10 & -1.8427e-14 \\
%		\end{tabular} 
%	\end{table}


%	\begin{figure}[h]
%		\centering
%		\includegraphics[width=1\textwidth]{images/wybor_cech.png}
%		\caption{Wykres wartoÅ›ci cech 2 i 4.}
%		\label{24}	
%	\end{figure}

\end{document}